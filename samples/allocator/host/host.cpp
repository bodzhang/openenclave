// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <openenclave/host.h>
#include <stdio.h>
#include <chrono>
#include <thread>
#include <vector>

// Include the untrusted allocator_demo_u.h header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "allocator_demo_u.h"

using namespace std;
using namespace std::chrono;

static uint32_t _num_threads = 8;
static uint64_t _num_iterations = 1000000;
static uint64_t _max_allocation_size = 4 * 1024;
static uint32_t _seed = time(NULL);

static uint32_t _flags = OE_ENCLAVE_FLAG_DEBUG;

static void _print_usage_and_exit(const char* argv[])
{
    printf(
        "usage:\n"
        "    %s default-enclave-path custom-enclave-path [--simulate] "
        "[--num-threads value] [--num-iterations value] [--seed value] "
        "[--max-allocation-size value]\n",
        argv[0]);
    exit(1);
}

static void _parse_args(int argc, const char* argv[])
{
    if (argc < 3)
        _print_usage_and_exit(argv);

    int i = 3;
    while (i < argc)
    {
        const char* arg = argv[i++];
        if (strcmp(arg, "--simulate") == 0)
            _flags |= OE_ENCLAVE_FLAG_SIMULATE;
        else if (strcmp(arg, "--num-threads") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%u", &_num_threads);
        }
        else if (strcmp(arg, "--num-iterations") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%lu", &_num_iterations);
        }
        else if (strcmp(arg, "--seed") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%u", &_seed);
        }
        else if (strcmp(arg, "--max-allocation-size") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%lu", &_max_allocation_size);
        }
        else
            _print_usage_and_exit(argv);
    }
}

static void _run_enclave(const char* enclave_path, const char* allocator_name)
{
    oe_enclave_t* enclave = NULL;
    oe_result_t result;

    fprintf(stdout, "Running enclave linked with %s\n", allocator_name);
    fprintf(stdout, "Loading enclave %s\n", enclave_path);

    // Create the enclave
    result = oe_create_allocator_demo_enclave(
        enclave_path, OE_ENCLAVE_TYPE_AUTO, _flags, NULL, 0, &enclave);

    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "oe_create_alloctor_demo_enclave(): result=%u (%s)\n",
            result,
            oe_result_str(result));
        goto exit;
    }

    // Configure enclave.
    {
        result = enclave_configure(enclave, _seed, _max_allocation_size);
        if (result != OE_OK)
        {
            fprintf(
                stderr,
                "enclave_configure(): result=%u (%s)\n",
                result,
                oe_result_str(result));
            goto exit;
        }
    }

    // Launch enclave threads that perform lots of memory allocations and
    // deallocations. Measure and print the elapsed time.
    {
        auto start_time = high_resolution_clock::now();
        vector<thread> threads(_num_threads);
        for (uint32_t i = 0; i < _num_threads; ++i)
            threads[i] = std::thread(
                [enclave]() { enclave_thread(enclave, _num_iterations); });

        for (uint32_t i = 0; i < _num_threads; ++i)
            threads[i].join();
        auto end_time = high_resolution_clock::now();
        auto elapsed =
            duration_cast<milliseconds>(end_time - start_time).count();

        printf("Elapsed time = %lu milliseconds\n", elapsed);
    }

exit:
    // Clean up the enclave if we created one
    if (enclave)
    {
        printf("Unloading enclave\n\n");
        oe_terminate_enclave(enclave);
    }
}

int main(int argc, const char* argv[])
{
    _parse_args(argc, argv);

    printf("Configuration:\n");
    printf(
        "    simulate = %s\n",
        (_flags & OE_ENCLAVE_FLAG_SIMULATE) ? "true" : "false");
    printf("    num-threads = %u\n", _num_threads);
    printf("    num-iterations = %lu\n", _num_iterations);
    printf("    seed = %u\n", _seed);
    printf("    max-allocation-size = %lu\n", _max_allocation_size);
    printf("\n\n");

    _run_enclave(argv[1], "default allocator");
    _run_enclave(argv[2], "oesnmalloc (pluggable allocator)");
}
